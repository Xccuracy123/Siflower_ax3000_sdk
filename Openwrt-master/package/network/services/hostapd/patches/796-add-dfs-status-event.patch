Index: hostapd-2022-01-16-cff80b4f/src/drivers/nl80211_copy.h
===================================================================
--- hostapd-2022-01-16-cff80b4f.orig/src/drivers/nl80211_copy.h
+++ hostapd-2022-01-16-cff80b4f/src/drivers/nl80211_copy.h
@@ -6206,6 +6206,7 @@ enum nl80211_smps_mode {
  *	applicable for ETSI dfs domain where pre-CAC is valid for ever.
  * @NL80211_RADAR_CAC_STARTED: Channel Availability Check has been started,
  *	should be generated by HW if NL80211_EXT_FEATURE_DFS_OFFLOAD is enabled.
+ * @NL80211_RADAR_DFS_STATUS_RESET: Reset radar channels dfs status to USABLE.
  */
 enum nl80211_radar_event {
 	NL80211_RADAR_DETECTED,
@@ -6214,6 +6215,7 @@ enum nl80211_radar_event {
 	NL80211_RADAR_NOP_FINISHED,
 	NL80211_RADAR_PRE_CAC_EXPIRED,
 	NL80211_RADAR_CAC_STARTED,
+	NL80211_RADAR_DFS_STATUS_RESET,
 };
 
 /**
Index: hostapd-2022-01-16-cff80b4f/src/ap/dfs.c
===================================================================
--- hostapd-2022-01-16-cff80b4f.orig/src/ap/dfs.c
+++ hostapd-2022-01-16-cff80b4f/src/ap/dfs.c
@@ -946,7 +946,7 @@ int hostapd_dfs_complete_cac(struct host
 		 * If it brings more questions, I am very sorry and please
 		 * tell me and remove it.
 		*/
-		hostapd_setup_interface_complete(iface, 1);
+		// hostapd_setup_interface_complete(iface, 1);
 	}
 
 	return 0;
@@ -1408,3 +1408,19 @@ int hostapd_is_dfs_overlap(struct hostap
 
 	return res;
 }
+
+void hostapd_dfs_reset_status(struct hostapd_iface *iface, int chan_width, int cf1, int cf2)
+{
+	struct hostapd_channel_data *channel;
+	int start_freq, end_freq;
+
+	start_freq = cf1 - chan_width / 2 + 10;
+	end_freq = cf1 + chan_width / 2 - 10;
+	for (int freq = start_freq; freq <= end_freq; freq += 20) {
+		channel = hw_mode_get_channel(iface->current_mode, freq, NULL);
+		if (channel && (channel->flag & HOSTAPD_CHAN_RADAR)) {
+			channel->flag &= ~HOSTAPD_CHAN_DFS_MASK;
+			channel->flag |= HOSTAPD_CHAN_DFS_USABLE;
+		}
+	}
+}
Index: hostapd-2022-01-16-cff80b4f/src/ap/dfs.h
===================================================================
--- hostapd-2022-01-16-cff80b4f.orig/src/ap/dfs.h
+++ hostapd-2022-01-16-cff80b4f/src/ap/dfs.h
@@ -32,5 +32,6 @@ int hostapd_dfs_start_cac(struct hostapd
 int hostapd_handle_dfs_offload(struct hostapd_iface *iface);
 int hostapd_is_dfs_overlap(struct hostapd_iface *iface, enum chan_width width,
 			   int center_freq);
+void hostapd_dfs_reset_status(struct hostapd_iface *iface, int chan_width, int cf1, int cf2);
 
 #endif /* DFS_H */
Index: hostapd-2022-01-16-cff80b4f/src/ap/drv_callbacks.c
===================================================================
--- hostapd-2022-01-16-cff80b4f.orig/src/ap/drv_callbacks.c
+++ hostapd-2022-01-16-cff80b4f/src/ap/drv_callbacks.c
@@ -1764,6 +1764,13 @@ static void hostapd_event_dfs_cac_starte
 			      radar->cf1, radar->cf2);
 }
 
+static void hostapd_event_dfs_status_reset(struct hostapd_data *hapd,
+					  struct dfs_event *radar)
+{
+	wpa_printf(MSG_DEBUG, "DFS status reset to usable on %d MHz width:%d center_freq1:%d center_freq2:%d",
+				radar->freq, radar->chan_width, radar->cf1, radar->cf2);
+	hostapd_dfs_reset_status(hapd->iface, channel_width_to_int(radar->chan_width), radar->cf1, radar->cf2);
+}
 #endif /* NEED_AP_MLME */
 
 
@@ -2050,6 +2057,11 @@ void hostapd_wpa_event(void *ctx, enum w
 			break;
 		hostapd_event_dfs_cac_started(hapd, &data->dfs_event);
 		break;
+	case EVENT_DFS_STATUS_RESET:
+		if (!data)
+			break;
+		hostapd_event_dfs_status_reset(hapd, &data->dfs_event);
+		break;
 #endif /* NEED_AP_MLME */
 	case EVENT_INTERFACE_ENABLED:
 		wpa_msg(hapd->msg_ctx, MSG_INFO, INTERFACE_ENABLED);
Index: hostapd-2022-01-16-cff80b4f/src/drivers/driver.h
===================================================================
--- hostapd-2022-01-16-cff80b4f.orig/src/drivers/driver.h
+++ hostapd-2022-01-16-cff80b4f/src/drivers/driver.h
@@ -5005,6 +5005,14 @@ enum wpa_event_type {
 	EVENT_DFS_NOP_FINISHED,
 
 	/**
+	 * EVENT_DFS_STATUS_RESET - Reset radar channels dfs status to available
+	 *
+	 * When stopping the AP, all radar channel states are reset to USABLE,
+	 * in order to support the subsequent feature of setting specific channels.
+	 */
+	EVENT_DFS_STATUS_RESET,
+
+	/**
 	 * EVENT_SURVEY - Received survey data
 	 *
 	 * This event gets triggered when a driver query is issued for survey
Index: hostapd-2022-01-16-cff80b4f/src/drivers/driver_nl80211_event.c
===================================================================
--- hostapd-2022-01-16-cff80b4f.orig/src/drivers/driver_nl80211_event.c
+++ hostapd-2022-01-16-cff80b4f/src/drivers/driver_nl80211_event.c
@@ -1844,6 +1844,9 @@ static void nl80211_radar_event(struct w
 	case NL80211_RADAR_CAC_STARTED:
 		wpa_supplicant_event(drv->ctx, EVENT_DFS_CAC_STARTED, &data);
 		break;
+	case NL80211_RADAR_DFS_STATUS_RESET:
+		wpa_supplicant_event(drv->ctx, EVENT_DFS_STATUS_RESET, &data);
+		break;
 	default:
 		wpa_printf(MSG_DEBUG, "nl80211: Unknown radar event %d "
 			   "received", event_type);
