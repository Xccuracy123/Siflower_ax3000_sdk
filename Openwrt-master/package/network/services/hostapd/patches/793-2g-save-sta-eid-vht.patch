Index: hostapd-2022-01-16-cff80b4f/src/ap/beacon.c
===================================================================
--- hostapd-2022-01-16-cff80b4f.orig/src/ap/beacon.c
+++ hostapd-2022-01-16-cff80b4f/src/ap/beacon.c
@@ -894,14 +894,43 @@ void handle_probe_req(struct hostapd_dat
 			   MAC2STR(mgmt->sa));
 		return;
 	}
+	if (elems.vht_capabilities && hapd->iconf->channel < 14) {
+		struct sta_vht_info_cache *cache, *prev  = NULL;
+		struct os_reltime now;
+		int found = 0;
 
+		cache = hapd->vht_cache;
+		os_get_reltime(&now);
+		while (cache) {
+			if (os_memcmp(cache->addr, mgmt->sa, ETH_ALEN) == 0) {
+				os_get_reltime(&cache->last_update);
+				found = 1;
+				break;
+			}
+			prev = cache;
+			cache = cache->next;
+		}
+		if (!found) {
+			struct sta_vht_info_cache *new_entry = NULL;
+
+			new_entry = os_zalloc(sizeof(struct sta_vht_info_cache));
+			if (!new_entry)
+				goto skip;
+			os_memcpy(new_entry->addr, mgmt->sa, ETH_ALEN);
+			os_memcpy(new_entry->vht_capab, elems.vht_capabilities, sizeof(struct ieee80211_vht_capabilities));
+			os_get_reltime(&new_entry->last_update);
+			new_entry->next = hapd->vht_cache;
+			hapd->vht_cache = new_entry;
+			hapd->vht_cache_count++;
+		}
+	}
+skip:
 	if ((!elems.ssid || !elems.supp_rates)) {
 		wpa_printf(MSG_DEBUG, "STA " MACSTR " sent probe request "
 			   "without SSID or supported rates element",
 			   MAC2STR(mgmt->sa));
 		return;
 	}
-
 	/*
 	 * No need to reply if the Probe Request frame was sent on an adjacent
 	 * channel. IEEE Std 802.11-2012 describes this as a requirement for an
Index: hostapd-2022-01-16-cff80b4f/src/ap/hostapd.c
===================================================================
--- hostapd-2022-01-16-cff80b4f.orig/src/ap/hostapd.c
+++ hostapd-2022-01-16-cff80b4f/src/ap/hostapd.c
@@ -456,9 +456,69 @@ static int hostapd_broadcast_wep_set(str
 
 #endif /* CONFIG_WEP */
 
+static void sta_vht_cache_cleanup(void *eloop_ctx, void *user_ctx)
+{
+	struct hostapd_data *hapd = eloop_ctx;
+	struct sta_vht_info_cache **pp;
+	struct sta_vht_info_cache *oldest = NULL;
+	struct sta_vht_info_cache **prev_oldest = NULL;
+	struct os_reltime now;
+	int count = 0;
+
+	if (!hapd || !hapd->vht_cache || hapd->iconf->channel > 14)
+		return;
+
+	os_get_reltime(&now);
+	pp = &hapd->vht_cache;
+	while (*pp) {
+		struct sta_vht_info_cache *entry = *pp;
+		if (now.sec - entry->last_update.sec > 300) {
+			*pp = entry->next;
+			os_free(entry);
+			hapd->vht_cache_count--;
+		} else {
+			pp = &entry->next;
+		}
+	}
+	while (hapd->vht_cache_count > 63) {
+		struct sta_vht_info_cache *oldest = NULL;
+		struct sta_vht_info_cache **prev_oldest = NULL;
+		pp = &hapd->vht_cache;
+
+		while (*pp) {
+			if (!oldest || os_reltime_before(&(*pp)->last_update, &oldest->last_update)) {
+				oldest = *pp;
+				prev_oldest = pp;
+			}
+			pp = &(*pp)->next;
+		}
+
+		if (oldest && prev_oldest) {
+			*prev_oldest = oldest->next;
+			os_free(oldest);
+			hapd->vht_cache_count--;
+		} else {
+			break;
+		}
+	}
+
+	eloop_register_timeout(120, 0, sta_vht_cache_cleanup, hapd, NULL);
+}
 
 void hostapd_free_hapd_data(struct hostapd_data *hapd)
 {
+	struct sta_vht_info_cache *entry, *next;
+
+	entry = hapd->vht_cache;
+	while (entry) {
+		next = entry->next;
+		os_free(entry);
+		entry = next;
+	}
+	hapd->vht_cache = NULL;
+	hapd->vht_cache_count = 0;
+	eloop_cancel_timeout(sta_vht_cache_cleanup, hapd, NULL);
+
 	os_free(hapd->probereq_cb);
 	hapd->probereq_cb = NULL;
 	hapd->num_probereq_cb = 0;
@@ -585,6 +645,7 @@ static void hostapd_cleanup(struct hosta
 		wpa_msg(hapd->msg_ctx, MSG_INFO, WPA_EVENT_TERMINATING);
 		hapd->iface->interfaces->ctrl_iface_deinit(hapd);
 	}
+
 	hostapd_free_hapd_data(hapd);
 }
 
@@ -2428,7 +2489,6 @@ int hostapd_setup_interface_complete(str
 	return 0;
 }
 
-
 /**
  * hostapd_setup_interface - Setup of an interface
  * @iface: Pointer to interface data.
@@ -2447,7 +2507,7 @@ int hostapd_setup_interface_complete(str
  */
 int hostapd_setup_interface(struct hostapd_iface *iface)
 {
-	int ret;
+	int ret, i;
 
 	if (!iface->conf)
 		return -1;
@@ -2457,7 +2517,11 @@ int hostapd_setup_interface(struct hosta
 			   iface->conf ? iface->conf->bss[0]->iface : "N/A");	
 		return -1;
 	}
-
+	for (i = 0; i < iface->num_bss; i++) {
+		struct hostapd_data *hapd = iface->bss[i];
+		if (hapd->iconf->channel < 14)
+			eloop_register_timeout(120, 0, sta_vht_cache_cleanup, hapd, NULL);
+	}
 	return 0;
 }
 
@@ -2505,7 +2569,8 @@ hostapd_alloc_bss_data(struct hostapd_if
 #ifdef CONFIG_SAE
 	dl_list_init(&hapd->sae_commit_queue);
 #endif /* CONFIG_SAE */
-
+	hapd->vht_cache = NULL;
+	hapd->vht_cache_count = 0;
 	return hapd;
 }
 
@@ -2530,7 +2595,7 @@ static void hostapd_bss_deinit(struct ho
 
 void hostapd_interface_deinit(struct hostapd_iface *iface)
 {
-	int j;
+	int j, i;
 
 	wpa_printf(MSG_DEBUG, "%s(%p)", __func__, iface);
 	if (iface == NULL)
Index: hostapd-2022-01-16-cff80b4f/src/ap/hostapd.h
===================================================================
--- hostapd-2022-01-16-cff80b4f.orig/src/ap/hostapd.h
+++ hostapd-2022-01-16-cff80b4f/src/ap/hostapd.h
@@ -169,6 +169,13 @@ struct hostapd_openwrt_stats {
 	} wnm;
 };
 
+struct sta_vht_info_cache {
+    u8 addr[ETH_ALEN];
+	u8 vht_capab[12] __attribute__((aligned(4))); ;
+    struct os_reltime last_update;
+    struct sta_vht_info_cache *next;
+};
+
 /**
  * struct hostapd_data - hostapd per-BSS data structure
  */
@@ -457,6 +464,8 @@ struct hostapd_data {
 #ifdef CONFIG_DRIVER_SIFLOWER
 	bool sf_enable_set_beacon;
 #endif
+	struct sta_vht_info_cache *vht_cache;
+	unsigned int vht_cache_count;
 };
 
 
Index: hostapd-2022-01-16-cff80b4f/src/ap/ieee802_11.c
===================================================================
--- hostapd-2022-01-16-cff80b4f.orig/src/ap/ieee802_11.c
+++ hostapd-2022-01-16-cff80b4f/src/ap/ieee802_11.c
@@ -4507,7 +4507,28 @@ static int check_assoc_ies(struct hostap
 
 #ifdef CONFIG_IEEE80211AC
 	if (hapd->iconf->ieee80211ac) {
+		struct sta_vht_info_cache *cache = NULL;
+		struct sta_vht_info_cache **prev = NULL;
+		bool found = false;
+		if (!elems.vht_capabilities) {
+			struct sta_vht_info_cache **pp = &hapd->vht_cache;
+			while (*pp) {
+				if (os_memcmp((*pp)->addr, sta->addr, ETH_ALEN) == 0) {
+					elems.vht_capabilities = (*pp)->vht_capab;
+					found = true;
+					cache = *pp;
+					prev = pp;
+					break;
+				}
+				pp = &(*pp)->next;
+			}
+		}
 		resp = copy_sta_vht_capab(hapd, sta, elems.vht_capabilities);
+		if (found && cache && prev) {
+			*prev = cache->next;
+			os_free(cache);
+			hapd->vht_cache_count--;
+		}
 		if (resp != WLAN_STATUS_SUCCESS)
 			return resp;
 
@@ -5866,6 +5887,22 @@ static void handle_assoc(struct hostapd_
 	}
 }
 
+static void sta_vht_info_cache_del(struct hostapd_data *hapd, struct sta_info *sta)
+{
+	struct sta_vht_info_cache **pp = &hapd->vht_cache;
+
+	while (*pp) {
+		if (os_memcmp((*pp)->addr, sta->addr, ETH_ALEN) == 0) {
+			struct sta_vht_info_cache *to_free = *pp;
+			*pp = to_free->next;
+			os_free(to_free);
+			hapd->vht_cache_count--;
+			break;
+		}
+		pp = &(*pp)->next;
+	}
+	return;
+}
 
 static void handle_disassoc(struct hostapd_data *hapd,
 			    const struct ieee80211_mgmt *mgmt, size_t len)
@@ -5902,6 +5939,7 @@ static void handle_disassoc(struct hosta
 	/* Stop Accounting and IEEE 802.1X sessions, but leave the STA
 	 * authenticated. */
 	accounting_sta_stop(hapd, sta);
+	sta_vht_info_cache_del(hapd, sta);
 	ieee802_1x_free_station(hapd, sta);
 	if (sta->ipaddr)
 		hostapd_drv_br_delete_ip_neigh(hapd, 4, (u8 *) &sta->ipaddr);
@@ -5973,6 +6011,7 @@ static void handle_deauth(struct hostapd
 		hapd, sta, le_to_host16(mgmt->u.deauth.reason_code));
 	sta->acct_terminate_cause = RADIUS_ACCT_TERMINATE_CAUSE_USER_REQUEST;
 	ieee802_1x_notify_port_enabled(sta->eapol_sm, 0);
+	sta_vht_info_cache_del(hapd, sta);
 	ap_free_sta(hapd, sta);
 }
 
